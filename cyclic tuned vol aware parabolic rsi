// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© ChartPrime

//@version=6
indicator("Cyclic tuned Parabolic RSI", overlay = false)

// ===================================================================
// --- CRSI #1 (original)
// ===================================================================
src = close
domcycle = input.int(20, minval=10, title="Dominant Cycle Length #1")
crsi = 0.0
cyclelen = domcycle / 2
vibration = 10
leveling = 10.0
cyclicmemory = domcycle * 2

h1 = hline(30, color=color.silver, linestyle=hline.style_dashed)
h2 = hline(70, color=color.silver, linestyle=hline.style_dashed)

torque = 2.0 / (vibration + 1)
phasingLag = (vibration - 1) / 2.0

up = ta.rma(math.max(ta.change(src), 0), cyclelen)
down = ta.rma(-math.min(ta.change(src), 0), cyclelen)
rsi = down == 0 ? 100 : up == 0 ? 0 : 100 - 100 / (1 + up / down)
crsi := torque * (2 * rsi - rsi[phasingLag]) + (1 - torque) * nz(crsi[1])

lmax = -999999.0
lmin = 999999.0
for i = 0 to cyclicmemory - 1 by 1
    if nz(crsi[i], -999999.0) > lmax
        lmax := nz(crsi[i])
    else
        if nz(crsi[i], 999999.0) < lmin
            lmin := nz(crsi[i])

mstep = (lmax - lmin) / 100
aperc = leveling / 100

db = 0.0
for steps = 0 to 100 by 1
    testvalue = lmin + mstep * steps
    below = 0
    for m = 0 to cyclicmemory - 1 by 1
        below := below + (crsi[m] < testvalue ? 1 : 0)
    ratio = below / cyclicmemory
    if ratio >= aperc
        db := testvalue
        break

ub = 0.0
for steps = 0 to 100 by 1
    testvalue = lmax - mstep * steps
    above = 0
    for m = 0 to cyclicmemory - 1 by 1
        above := above + (crsi[m] >= testvalue ? 1 : 0)
    ratio = above / cyclicmemory
    if ratio >= aperc
        ub := testvalue
        break

lowband = plot(db, "LowBand #1", color=color.aqua)
highband = plot(ub, "HighBand #1", color=color.aqua)
fill(h1, h2, color=color.rgb(178, 181, 190, 86))
fill(lowband, highband, color=color.rgb(120, 123, 134, 92))
plot(crsi, "CRSI #1", color=color.fuchsia)


// Detect break above HighBand
hbBreak = ta.crossunder(crsi, ub)

// Store previous HighBand break value
var float prevHbValue = na

if hbBreak
    labelText = na(prevHbValue) ? "HB" : crsi[1] > prevHbValue ? "HH" : "LH"    
    label.new(        bar_index,        crsi[1]+10,        labelText,        style=label.style_label_down,        color=labelText == "HH" ? color.green : color.orange,        textcolor=color.white,        size=size.small    )
    prevHbValue := crsi[1]

// Detect break above HighBand
lbBreak = ta.crossover(crsi, db)


// Store previous HighBand break value
var float prevLbValue = na

if lbBreak
    labelText = na(prevLbValue) ? "LB" : crsi[1] < prevLbValue ? "LL" : "HL"    
    label.new(        bar_index,        crsi[1]-10,        labelText,        style=label.style_label_up,        color=labelText == "HL" ? color.orange : color.red,        textcolor=color.white,        size=size.small    )
    prevLbValue := crsi[1]



upper_ = input.int(70, "Threshold: â­±", inline = "Threshold")
lower_ = input.int(30, " â¤“", inline = "Threshold")

display_sar = input.bool(true, "SAR", group = "SAR")
start       = input.float(0.02, "Start", step = 0.01, inline = "sar", group = "SAR")
inc         = input.float(0.02, "Increment", step = 0.01, inline = "sar", group = "SAR")
max         = input.float(0.2, "Maximum", step = 0.01, inline = "sar", group = "SAR")
color_up    = input.color(#EEA47F, "", inline = "c")
color_dn    = input.color(#00539C, "", inline = "c")
smalen = input.int(20, "SMA Length")
rellen = input.int(20, "Relative Volume Length")
zlen   = input.int(20, "Z-Score Length")
tf            = input.timeframe('1', 'LTF Timeframe')

mult   = input.float(1.0, "Multiplier 1")
mult2  = input.float(1.5, "Multiplier 2")
mult3  = input.float(2.0, "Multiplier 3")

upcol_mult1 = input.color(color.green, "Buy Color")
upcol_mult2 = input.color(color.rgb(130, 177, 131), "Buy Color")
upcol_mult3 = input.color(color.rgb(218, 255, 220), "Buy Color")
dncol_mult1 = input.color(color.red, "Sell Color")
dncol_mult2 = input.color(color.rgb(177, 130, 130), "Sell Color")
dncol_mult3 = input.color(color.rgb(255, 218, 218), "Sell Color")

// === FUNCTIONS === //
// SMA Function
f_mult1(src) => ta.sma(src, smalen) * (mult + 1)
f_mult2(src) => ta.sma(src, smalen) * (mult2 + 1)
f_mult3(src) => ta.sma(src, smalen) * (mult3 + 1)

// Relative function
f_relative(src) => src / ta.sma(src, rellen)

// Z-Score function
f_zscore(src) =>
    mean = ta.sma(src, zlen)
    std  = ta.stdev(src, zlen)
    (src - mean) / std

// === VOLUME LOGIC === //
vol = volume
vol_sma = f_mult1(vol)
vol_sma2 = f_mult2(vol)
vol_sma3 = f_mult3(vol)

rvol = f_relative(volume)
rvol_sma = f_mult1(rvol)
rvol_sma2 = f_mult2(rvol)
rvol_sma3 = f_mult3(rvol)

obv = ta.cum(close > open ? rvol : -rvol)

[buy_volume, sell_volume] = request.security_lower_tf(syminfo.tickerid, tf, [close > open ? volume : 0, close < open ? volume : 0])
// === PARAMETERS === //




buy_vol = array.sum(buy_volume)
sell_vol = array.sum(sell_volume)
delta_vol = buy_vol - sell_vol
cum_delta_vol = ta.cum(delta_vol)
delta_abs = math.abs(delta_vol)

rposdelta = f_relative(delta_vol > 0 ? delta_vol : 0)
rnegdelta = f_relative(delta_vol < 0 ? delta_vol : 0)

vdp_sma = f_mult1(delta_vol > 0 ? delta_vol : 0) * 2
vdp_sma2 = f_mult2(delta_vol > 0 ? delta_vol : 0) * 3
vdp_sma3 = f_mult3(delta_vol > 0 ? delta_vol : 0) * 7

vdn_sma = f_mult1(delta_vol < 0 ? delta_vol : 0) * 2
vdn_sma2 = f_mult2(delta_vol < 0 ? delta_vol : 0) * 3
vdn_sma3 = f_mult3(delta_vol < 0 ? delta_vol : 0) * 7

bvl_sma = f_mult1(buy_vol)
bvl2_sma = f_mult2(buy_vol)
bvl3_sma = f_mult3(buy_vol)

svl_sma = f_mult1(sell_vol)
svl2_sma = f_mult2(sell_vol)
svl3_sma = f_mult3(sell_vol)

// === DATE MATCHING === //aaaaaaaaaaaaa
// === PLOT VERTICAL LINES === //


// --------------------------------------------------------------------------------------------------------------------}
// ð™„ð™‰ð˜¿ð™„ð˜¾ð˜¼ð™ð™Šð™ ð˜¾ð˜¼ð™‡ð˜¾ð™ð™‡ð˜¼ð™ð™„ð™Šð™‰ð™Ž
// --------------------------------------------------------------------------------------------------------------------{



pine_sar(src, start, inc, max) =>

    src_high = src+1
    src_low  = src-1

    var float result = na
    var float maxMin = na
    var float acceleration = na
    var bool isBelow = false
    bool isFirstTrendBar = false
    
    if bar_index <= domcycle+2
        if src > src[1]
            isBelow := true
            maxMin := src_high
            result := src_low[1]
        else
            isBelow := false
            maxMin := src_low
            result := src_high[1]
            
        isFirstTrendBar := true
        acceleration := start
    
    result := result + acceleration * (maxMin - result)
    
    if isBelow
        if result > src_low
            isFirstTrendBar := true
            isBelow := false
            result := math.max(src_high, maxMin)
            maxMin := src_low
            acceleration := start
    else
        if result < src_high
            isFirstTrendBar := true
            isBelow := true
            result := math.min(src_low, maxMin)
            maxMin := src_high
            acceleration := start
            
    if not isFirstTrendBar
        if isBelow
            if src_high > maxMin
                maxMin := src_high
                acceleration := math.min(acceleration + inc, max)
        else
            if src_low < maxMin
                maxMin := src_low
                acceleration := math.min(acceleration + inc, max)
    
    if isBelow
        result := math.min(result, src_low[1])
        if bar_index > 1
            result := math.min(result, src_low[2])
        
    else
        result := math.max(result, src_high[1])
        if bar_index > 1
            result := math.max(result, src_high[2])
    
    [result, isBelow]

[sar_rsi, isBelow] = pine_sar(crsi, start, inc, max)


sig_up = isBelow != isBelow[1] and isBelow and barstate.isconfirmed
sig_dn = isBelow != isBelow[1] and not isBelow and barstate.isconfirmed

s_sig_up = isBelow != isBelow[1] and isBelow and barstate.isconfirmed and sar_rsi <= lower_
s_sig_dn = isBelow != isBelow[1] and not isBelow and barstate.isconfirmed and sar_rsi >= upper_

var sar = float(na)

if display_sar
    sar := isBelow != isBelow[1] ? na : sar_rsi

sar_col = isBelow ? color_up : color_dn
sar_col := delta_vol > 0 and delta_vol > vdp_sma ? upcol_mult1 : sar_col
sar_col := delta_vol > 0 and delta_vol > vdp_sma2 ? upcol_mult1 : sar_col
sar_col := delta_vol > 0 and delta_vol > vdp_sma3 ? upcol_mult1 : sar_col
sar_col := delta_vol < 0 and delta_vol < vdn_sma ? dncol_mult1 : sar_col
sar_col := delta_vol < 0 and delta_vol < vdn_sma2 ? dncol_mult1 : sar_col
sar_col := delta_vol < 0 and delta_vol < vdn_sma3 ? dncol_mult1 : sar_col

// --------------------------------------------------------------------------------------------------------------------}
// ð™‘ð™„ð™Žð™ð˜¼ð™‡ð™„ð™•ð˜¼ð™ð™„ð™Šð™‰
// --------------------------------------------------------------------------------------------------------------------{

rsiPlot = plot(crsi, "RSI", color=chart.fg_color)
rsiUpperBand = hline(upper_, "RSI Upper Band", color=#787B86)
midline = hline(50, "RSI Middle Band", color=color.new(#787B86, 50))
rsiLowerBand = hline(lower_, "RSI Lower Band", color=#787B86)
fill(rsiUpperBand, rsiLowerBand, color=#c292571a, title="RSI Background Fill")
midLinePlot = plot(50, color = na, editable = false, display = display.none)
fill(rsiPlot, midLinePlot, 100, 70, top_color = color.new(color.red, 0), bottom_color = color.new(color.orange, 100),  title = "Overbought Gradient Fill")
fill(rsiPlot, midLinePlot, 30,  0,  top_color = color.new(color.red, 100), bottom_color = color.new(color.orange, 0),      title = "Oversold Gradient Fill")


sar_p = plot(sar, "SAR", color = sar_col, style = plot.style_circles)

plotshape(sig_up and sar_rsi >= lower_ ? sar_rsi : na, "Rsi Up", shape.diamond, location.absolute, size = size.tiny, color = sar_col)
plotshape(sig_dn and sar_rsi <= upper_  ? sar_rsi : na, "Rsi Dn", shape.diamond, location.absolute, size = size.tiny, color = sar_col)

plotchar(s_sig_up ? sar_rsi : na, "Rsi Up", "â—ˆ", location.absolute, size = size.tiny, color = sar_col)
plotchar(s_sig_dn ? sar_rsi : na, "Rsi Dn", "â—ˆ", location.absolute, size = size.tiny, color = sar_col)


plotshape(s_sig_up, "Chart Strong Rsi Up", shape.diamond, location.belowbar, size = size.small, color = sar_col, force_overlay = true)
plotshape(s_sig_dn, "Chart Strong Rsi Dn", shape.diamond, location.abovebar, size = size.small, color = sar_col, force_overlay = true)

plotshape(sig_up and sar_rsi >= lower_, "Chart Rsi Up", shape.diamond, location.belowbar, size = size.tiny, color = sar_col, force_overlay = true)
plotshape(sig_dn and sar_rsi <= upper_, "Chart Rsi Dn", shape.diamond, location.abovebar, size = size.tiny, color = sar_col, force_overlay = true)// --------------------------------------------------------------------------------------------------------------------}
